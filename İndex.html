<html lang="tr" class="scroll-smooth">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cube AI Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap"
    rel="stylesheet"
  />
  <style>
    body {
      font-family: 'Roboto Mono', monospace;
      overscroll-behavior: none;
      background-color: #000;
      color: #fff;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    /* Scrollbar for chat container */
    .chat-scroll::-webkit-scrollbar {
      width: 6px;
    }
    .chat-scroll::-webkit-scrollbar-thumb {
      background-color: #555;
      border-radius: 3px;
    }
    /* Sidebar menu styles */
    #menuOverlay {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 280px;
      max-width: 80vw;
      background-color: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(8px);
      z-index: 1000;
      transform: translateX(-100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 4px 0 12px rgb(0 0 0 / 0.8);
    }
    #menuOverlay.open {
      transform: translateX(0);
    }
    #menuOverlay header {
      padding: 1.5rem 1.5rem 1rem;
      border-bottom: 1px solid #222;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    #menuOverlay header h2 {
      font-size: 1.5rem;
      font-weight: 700;
      color: #fff;
      user-select: none;
    }
    #menuOverlay header button.closeBtn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 0.375rem;
      transition: background-color 0.3s ease;
    }
    #menuOverlay header button.closeBtn:hover,
    #menuOverlay header button.closeBtn:focus {
      background-color: #222;
      outline: none;
    }
    #menuOverlay nav {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      font-size: 1.125rem;
      font-weight: 600;
      color: #fff;
    }
    #menuOverlay nav section {
      border-bottom: 1px solid #222;
      padding-bottom: 1rem;
      display: flex;
      flex-direction: column;
    }
    #menuOverlay nav section:last-child {
      border-bottom: none;
      padding-bottom: 0;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    #menuOverlay nav section h3 {
      margin-bottom: 0.75rem;
      font-weight: 700;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #menuOverlay nav a,
    #menuOverlay nav button {
      display: block;
      color: #fff;
      text-decoration: none;
      padding: 0.5rem 0.75rem;
      border-radius: 0.375rem;
      background-color: transparent;
      text-align: left;
      cursor: pointer;
      transition: background-color 0.3s ease;
      font-weight: 500;
      user-select: text;
      border: none;
      width: 100%;
    }
    #menuOverlay nav a:hover,
    #menuOverlay nav a:focus,
    #menuOverlay nav button:hover,
    #menuOverlay nav button:focus {
      background-color: #222;
      outline: none;
    }
    #menuOverlay nav button {
      font-family: inherit;
    }
    #menuOverlay nav .chat-history-list {
      overflow-y: auto;
      border: 1px solid #222;
      border-radius: 0.5rem;
      background-color: #111;
      padding: 0.5rem;
      font-size: 0.9rem;
      font-weight: 400;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      flex-grow: 1;
      min-height: 100px;
      max-height: 250px;
    }
    #menuOverlay nav .chat-history-list button {
      padding: 0.4rem 0.6rem;
      font-size: 0.9rem;
      font-weight: 500;
      border-radius: 0.375rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      background-color: transparent;
      border: none;
      cursor: pointer;
      color: #ccc;
      transition: background-color 0.3s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #menuOverlay nav .chat-history-list button:hover,
    #menuOverlay nav .chat-history-list button:focus {
      background-color: #333;
      outline: none;
      color: #fff;
    }
    #menuOverlay nav .chat-history-list button .date {
      font-size: 0.75rem;
      color: #777;
      margin-left: 0.5rem;
      flex-shrink: 0;
      white-space: nowrap;
    }
    #menuOverlay nav .chat-history-info {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: #888;
      user-select: none;
      text-align: center;
      font-style: italic;
    }
    /* Android style top bar shadow */
    nav#mainNav {
      box-shadow: 0 2px 4px rgb(0 0 0 / 0.7);
      z-index: 1100;
      background-color: #000;
    }
    /* Scroll container for chat */
    main#chatContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 600px;
      margin: 0 auto;
      width: 100%;
      padding: 1.5rem 1rem 1rem;
      overflow: hidden;
      background-color: #000;
      position: relative;
    }
    #chat {
      flex: 1;
      overflow-y: auto;
      padding-right: 0.5rem;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scrollbar-color: #555 transparent;
      user-select: text;
      font-size: 1rem;
      line-height: 1.4;
      position: relative;
    }
    /* Message bubbles */
    .message-wrapper {
      position: relative;
      max-width: 80%;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      user-select: text;
      font-family: 'Roboto Mono', monospace;
    }
    .message-wrapper.user {
      align-self: flex-end;
      align-items: flex-end;
    }
    .message-wrapper.ai {
      align-self: flex-start;
      align-items: flex-start;
    }
    .message {
      padding: 1rem 1.25rem;
      border-radius: 1rem;
      word-break: break-word;
      white-space: pre-wrap;
      font-size: 1rem;
      line-height: 1.4;
      user-select: text;
      cursor: default;
      max-width: 100%;
      box-sizing: border-box;
    }
    .message.user {
      background-color: #fff;
      color: #000;
      border-top-right-radius: 0;
      animation: fadeIn 0.3s ease forwards;
    }
    .message.ai {
      background-color: #111;
      color: #ccc;
      border-top-left-radius: 0;
      animation: fadeIn 0.3s ease forwards;
    }
    /* Code block inside AI message */
    .message.ai pre {
      background-color: #222;
      color: #ccc;
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      font-family: 'Fira Code', 'Courier New', Courier, monospace;
      font-size: 0.9rem;
      overflow-x: auto;
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      user-select: text;
      position: relative;
    }
    .message.ai pre code {
      display: block;
      white-space: pre-wrap;
      color: #ccc;
    }
    /* Copy button for code blocks */
    .copy-btn {
      position: absolute;
      top: 0.25rem;
      right: 0.25rem;
      background-color: rgba(255,255,255,0.2);
      color: #ccc;
      border: none;
      border-radius: 0.375rem;
      padding: 0.15rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s ease;
      z-index: 10;
    }
    .copy-btn:hover,
    .copy-btn:focus {
      background-color: rgba(255,255,255,0.4);
      outline: none;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    /* Input area */
    form#chatForm {
      display: flex;
      gap: 0.5rem;
      border-top: 1px solid #222;
      padding-top: 0.75rem;
      user-select: none;
      position: relative;
      align-items: stretch;
      background-color: transparent;
    }
    textarea#messageInput {
      flex: 1;
      resize: none;
      border-radius: 0.5rem;
      background-color: #111;
      color: #fff;
      border: 1.5px solid #ccc;
      padding: 0.75rem 1rem;
      font-family: 'Roboto Mono', monospace;
      font-size: 1rem;
      line-height: 1.4;
      min-height: 2.75rem;
      max-height: 6rem;
      overflow-y: auto;
      user-select: text;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
      box-sizing: border-box;
      line-height: 1.25rem;
      outline-offset: 2px;
    }
    textarea#messageInput:focus {
      outline: none;
      background-color: #222;
      border-color: #fff;
      color: #fff;
      box-shadow: 0 0 8px 2px #fff;
    }
    button#sendBtn, button#stopBtn {
      background-color: #fff;
      color: #000;
      border: none;
      border-radius: 0.5rem;
      padding: 0 0.75rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s ease, color 0.3s ease;
      user-select: none;
      min-width: 2.75rem;
      height: 2.75rem;
      font-size: 1.25rem;
      flex-shrink: 0;
      box-shadow: none;
    }
    button#sendBtn i, button#stopBtn i {
      margin: 0;
    }
    button#sendBtn:hover,
    button#sendBtn:focus {
      background-color: #ddd;
      color: #000;
      outline: none;
    }
    button#stopBtn:hover,
    button#stopBtn:focus {
      background-color: #ddd;
      color: #000;
      outline: none;
    }
    button#sendBtn:disabled {
      background-color: #bbb;
      color: #666;
      cursor: not-allowed;
    }
    button#stopBtn {
      display: none;
    }
    /* Disable textarea scrollbar on iOS */
    textarea#messageInput::-webkit-scrollbar {
      display: none;
    }
    /* Prevent body scroll when menu open */
    body.menu-open {
      overflow: hidden;
      touch-action: none;
    }
    /* Loading spinner for AI waiting */
    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top: 3px solid #fff;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      margin-left: 0.5rem;
      flex-shrink: 0;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    /* Initial loading overlay */
    #initialLoadingOverlay {
      position: fixed;
      inset: 0;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      flex-direction: column;
      gap: 1rem;
      user-select: none;
    }
    #initialLoadingOverlay img {
      width: 80px;
      height: 80px;
      object-fit: contain;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.6;
        transform: scale(1.1);
      }
    }
    /* Profile and Settings pages */
    #profilePage, #settingsPage, #modelsPage {
      position: fixed;
      top: 0;
      left: 280px;
      max-width: calc(100vw - 280px);
      width: calc(100% - 280px);
      height: 100vh;
      background-color: #111;
      color: #fff;
      padding: 2rem 2rem 2rem 2rem;
      overflow-y: auto;
      z-index: 1500;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      font-family: 'Roboto Mono', monospace;
    }
    #profilePage.open, #settingsPage.open, #modelsPage.open {
      transform: translateX(0);
    }
    #profilePage header, #settingsPage header, #modelsPage header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
    }
    #profilePage header h2, #settingsPage header h2, #modelsPage header h2 {
      font-size: 2rem;
      font-weight: 700;
      color: #fff;
      text-shadow: none;
    }
    #profilePage button.closePageBtn, #settingsPage button.closePageBtn, #modelsPage button.closePageBtn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.75rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 0.375rem;
      transition: background-color 0.3s ease;
    }
    #profilePage button.closePageBtn:hover, #profilePage button.closePageBtn:focus,
    #settingsPage button.closePageBtn:hover, #settingsPage button.closePageBtn:focus,
    #modelsPage button.closePageBtn:hover, #modelsPage button.closePageBtn:focus {
      background-color: #222;
      outline: none;
    }
    #profilePage section, #settingsPage section, #modelsPage section {
      margin-bottom: 2rem;
      max-width: 480px;
      width: 100%;
    }
    #profilePage label, #settingsPage label, #modelsPage label {
      display: block;
      margin-bottom: 0.75rem;
      font-weight: 700;
      font-size: 1.1rem;
      color: #fff;
      user-select: none;
    }
    #profilePage input, #settingsPage input, #settingsPage select, #modelsPage input, #modelsPage select {
      width: 100%;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      border: 2px solid #fff;
      background-color: #000;
      color: #fff;
      font-family: 'Roboto Mono', monospace;
      font-size: 1.1rem;
      box-sizing: border-box;
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }
    #profilePage input:focus, #settingsPage input:focus, #settingsPage select:focus, #modelsPage input:focus, #modelsPage select:focus {
      outline: none;
      box-shadow: 0 0 10px 2px #fff;
      background-color: #111;
      border-color: #fff;
    }
    #settingsPage button.saveSettingsBtn {
      background-color: #000;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 0.75rem;
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      font-weight: 700;
      font-family: 'Roboto Mono', monospace;
      font-size: 1.1rem;
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
      align-self: flex-start;
      box-shadow: none;
    }
    #settingsPage button.saveSettingsBtn:hover,
    #settingsPage button.saveSettingsBtn:focus {
      background-color: #fff;
      color: #000;
      border-color: #000;
      outline: none;
      box-shadow: none;
    }
    /* Responsive adjustments */
    @media (max-width: 640px) {
      #menuOverlay {
        width: 100vw;
        max-width: 100vw;
      }
      #profilePage, #settingsPage, #modelsPage {
        left: 0;
        width: 100vw;
        max-width: 100vw;
        padding: 1.5rem 1rem 1.5rem 1rem;
      }
      #profilePage section, #settingsPage section, #modelsPage section {
        margin-bottom: 1.5rem;
      }
      #profilePage header h2, #settingsPage header h2, #modelsPage header h2 {
        font-size: 1.5rem;
      }
      #settingsPage button.saveSettingsBtn {
        padding: 0.6rem 1.2rem;
        font-size: 1rem;
      }
    }
    /* Editable message textarea */
    .edit-textarea {
      width: 100%;
      font-family: 'Roboto Mono', monospace;
      font-size: 1rem;
      line-height: 1.4;
      padding: 0.75rem 1rem;
      border-radius: 1rem;
      border: 1.5px solid #fff;
      background-color: #000;
      color: #fff;
      resize: vertical;
      min-height: 2.5rem;
      max-height: 6rem;
      box-sizing: border-box;
      outline-offset: 2px;
    }
    .edit-textarea:focus {
      outline: none;
      box-shadow: 0 0 8px 2px #fff;
      background-color: #111;
    }
    /* Buttons container for edit mode */
    .edit-buttons {
      margin-top: 0.25rem;
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
    }
    .edit-buttons button {
      background-color: #fff;
      color: #000;
      border: none;
      border-radius: 0.5rem;
      padding: 0.3rem 0.75rem;
      font-weight: 700;
      cursor: pointer;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.9rem;
      transition: background-color 0.3s ease;
      user-select: none;
    }
    .edit-buttons button:hover,
    .edit-buttons button:focus {
      background-color: #ddd;
      outline: none;
    }
    .edit-buttons button.cancel-btn {
      background-color: #555;
      color: #eee;
    }
    .edit-buttons button.cancel-btn:hover,
    .edit-buttons button.cancel-btn:focus {
      background-color: #333;
      color: #ccc;
      outline: none;
    }
    /* Action bar below messages */
    .action-bar {
      display: flex;
      gap: 0.5rem;
      font-size: 0.75rem;
      user-select: none;
    }
    .action-bar button {
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      padding: 0.15rem 0.4rem;
      border-radius: 0.375rem;
      transition: background-color 0.2s ease;
      font-family: 'Roboto Mono', monospace;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    .action-bar button:hover,
    .action-bar button:focus {
      background-color: #444;
      color: #fff;
      outline: none;
    }
    .action-bar button svg {
      width: 14px;
      height: 14px;
    }
    /* Selected model button style */
    .model-selected {
      background-color: #2563eb !important; /* Tailwind blue-600 */
      color: white !important;
      cursor: default !important;
    }
    /* Disabled action bar style */
    .action-bar.disabled {
      pointer-events: none;
      opacity: 0.5;
      user-select: none;
    }
  </style>
</head>
<body>
  <!-- Initial loading overlay -->
  <div id="initialLoadingOverlay" role="alert" aria-live="assertive" aria-label="Yükleniyor">
    <img
      src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnCMOZ7JUNuSDw7yEvcZV2Xw6t7Fc76R6OVdIEVR4hEI32HwZlEgXSZCRU2YGxhZ9oicU7nrk3PqZanBQWDzuPTQaNRpX66Xvja1phi9L2aXMeaF7F7ykWKwYA1eirlNOLaFvq32OXXJap6hUPbunojLTtdB0B4uvFGqd2kVshNo2_P50mwixwTu1mSA/s1080/BackgroundEraser_20250503_224811525.png"
      alt="Cube AI Chat logo, siyah arka plan üzerinde beyaz stilize küp"
      draggable="false"
    />
    <div class="spinner" aria-hidden="true"></div>
  </div>

  <!-- Navbar -->
  <nav
    id="mainNav"
    class="flex items-center justify-between px-4 py-3 select-none"
    role="navigation"
    aria-label="Ana navigasyon"
  >
    <div class="flex items-center space-x-3">
      <img
        src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnCMOZ7JUNuSDw7yEvcZV2Xw6t7Fc76R6OVdIEVR4hEI32HwZlEgXSZCRU2YGxhZ9oicU7nrk3PqZanBQWDzuPTQaNRpX66Xvja1phi9L2aXMeaF7F7ykWKwYA1eirlNOLaFvq32OXXJap6hUPbunojLTtdB0B4uvFGqd2kVshNo2_P50mwixwTu1mSA/s1080/BackgroundEraser_20250503_224811525.png"
        alt="Cube AI Chat logo, a black and white stylized cube with sharp edges and minimalistic design"
        class="h-10 w-10 object-contain"
        draggable="false"
      />
      <span class="text-xl font-bold tracking-wide select-none">Cube</span>
    </div>

    <div class="flex items-center space-x-2">
      <button
        id="menuButton"
        aria-haspopup="true"
        aria-expanded="false"
        aria-label="Menüyü aç"
        class="focus:outline-none focus:ring-2 focus:ring-white p-2 rounded-md hover:bg-gray-800"
        type="button"
      >
        <i class="fas fa-bars text-xl" aria-hidden="true"></i>
      </button>
      <button
        id="openModelsBtnNavbar"
        type="button"
        aria-label="Modeller sayfasını aç"
        class="text-white font-semibold px-3 py-1 rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-white hidden sm:inline-block"
      >
        Modeller
      </button>
    </div>
  </nav>

  <!-- Sidebar menu overlay -->
  <aside
    id="menuOverlay"
    role="menu"
    aria-label="Ana menü"
    tabindex="-1"
    aria-hidden="true"
  >
    <header>
      <h2>Menü</h2>
      <button
        class="closeBtn"
        aria-label="Menüyü kapat"
        type="button"
        title="Menüyü kapat"
      >
        <i class="fas fa-times" aria-hidden="true"></i>
      </button>
    </header>
    <nav>
      <section aria-label="Yeni Sohbet">
        <h3>Yeni Sohbet</h3>
        <button id="newChatBtn" type="button" tabindex="0">Yeni Sohbet </button>
      </section>
      <section aria-label="Profil">
        <h3>seçenekler</h3>
        <button id="openProfileBtn" type="button" tabindex="0">Profil Bilgileri</button>
        <button id="openSettingsBtn" type="button" tabindex="0">Hesap Ayarları</button>
        <button id="openModelsBtn" type="button" tabindex="0">Modeller</button>
      </section>
      <section aria-label="Sohbet Geçmişi" class="flex flex-col flex-grow">
        <h3>Sohbet Geçmişi</h3>
        <div class="chat-history-list" tabindex="0" aria-label="Sohbet geçmişi listesi"></div>
        <div class="chat-history-info" aria-live="polite" aria-atomic="true">Mesajlar 7 gün içinde otomatik olarak silinir.</div>
      </section>
    </nav>
  </aside>

  <!-- Profile Page -->
  <section id="profilePage" aria-label="Profil Sayfası" tabindex="0" role="region" aria-hidden="true">
    <header>
      <h2>Profil Bilgileri</h2>
      <button class="closePageBtn" aria-label="Profil sayfasını kapat" title="Profil sayfasını kapat" type="button">
        <i class="fas fa-times"></i>
      </button>
    </header>
    <section>
      <label for="profileName">İsim</label>
      <input type="text" id="profileName" name="profileName" placeholder="İsminizi girin" autocomplete="name" />
    </section>
    <section>
      <label for="profileEmail">E-posta</label>
      <input type="email" id="profileEmail" name="profileEmail" placeholder="E-posta adresinizi girin" autocomplete="email" />
    </section>
  </section>

  <!-- Settings Page -->
  <section id="settingsPage" aria-label="Ayarlar Sayfası" tabindex="0" role="region" aria-hidden="true">
    <header>
      <h2>Hesap Ayarları</h2>
      <button class="closePageBtn" aria-label="Ayarlar sayfasını kapat" title="Ayarlar sayfasını kapat" type="button">
        <i class="fas fa-times"></i>
      </button>
    </header>
    <section>
      <label for="themeSelect">Tema</label>
      <select id="themeSelect" name="themeSelect" aria-label="Tema seçimi">
        <option value="dark" selected>Koyu</option>
        <option value="light">Açık</option>
      </select>
    </section>
    <section>
      <label for="fontSizeSelect">Yazı Boyutu</label>
      <select id="fontSizeSelect" name="fontSizeSelect" aria-label="Yazı boyutu seçimi">
        <option value="small">Küçük</option>
        <option value="medium" selected>Orta</option>
        <option value="large">Büyük</option>
      </select>
    </section>
    <section>
      <label for="languageSelect">Dil</label>
      <select id="languageSelect" name="languageSelect" aria-label="Dil seçimi">
        <option value="tr" selected>Türkçe</option>
        <option value="en">English</option>
        <option value="de">Deutsch</option>
        <option value="fr">Français</option>
        <option value="es">Español</option>
        <option value="zh">中文</option>
        <option value="ja">日本語</option>
        <option value="ru">Русский</option>
        <option value="ar">العربية</option>
        <option value="pt">Português</option>
        <option value="hi">हिन्दी</option>
        <option value="it">Italiano</option>
        <option value="ko">한국어</option>
        <option value="nl">Nederlands</option>
        <option value="sv">Svenska</option>
        <option value="pl">Polski</option>
        <option value="fi">Suomi</option>
        <option value="no">Norsk</option>
        <option value="da">Dansk</option>
        <option value="cs">Čeština</option>
        <option value="el">Ελληνικά</option>
        <option value="he">עברית</option>
        <option value="th">ไทย</option>
        <option value="vi">Tiếng Việt</option>
        <option value="id">Bahasa Indonesia</option>
      </select>
    </section>
    <button class="saveSettingsBtn" type="button" aria-label="Ayarları kaydet">Ayarları Kaydet</button>
  </section>

  <!-- Models Page -->
  <section id="modelsPage" aria-label="Modeller Sayfası" tabindex="0" role="region" aria-hidden="true">
    <header>
      <h2>Modeller</h2>
      <button class="closePageBtn" aria-label="Modeller sayfasını kapat" title="Modeller sayfasını kapat" type="button">
        <i class="fas fa-times"></i>
      </button>
    </header>
    <section>
      <p>Burada kullanılabilir modelleri seçebilirsiniz.</p>
      <ul class="space-y-4 max-w-md">
        <li class="flex items-center justify-between bg-gray-900 rounded-lg p-4">
          <div>
            <h3 class="font-bold text-lg">gemini 1.5</h3>
            <p class="text-gray-400 text-sm">Orta seviye görevler için gelişmiş model.</p>
          </div>
          <div class="flex items-center space-x-2">
            <button
              type="button"
              class="select-model-btn bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400"
              data-model="gemini-1.5"
              data-api-key="AIzaSyC-WNbSjuFatBsUomfL3jfVu7pWOIlGCzc"
              aria-label="gemini 1.5 modelini seç"
            >
              Seç
            </button>
          </div>
        </li>
        <li class="flex items-center justify-between bg-gray-900 rounded-lg p-4">
          <div>
            <h3 class="font-bold text-lg">gemini 2.5</h3>
            <p class="text-gray-400 text-sm">Yüksek performanslı ve güçlü model.</p>
          </div>
          <div class="flex items-center space-x-2">
            <button
              type="button"
              class="select-model-btn bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400"
              data-model="gemini-2.5"
              data-api-key="AIzaSyDhhDRN1MvSSTT7WG-8wFNdwF83PKq7_dw"
              aria-label="gemini 2.5 modelini seç"
            >
              Seç
            </button>
          </div>
        </li>
      </ul>
      <p class="mt-4 text-sm text-gray-400">Seçilen model: <span id="selectedModelName" class="font-semibold">gpt-3.5-turbo</span></p>
    </section>
  </section>

  <!-- Chat container -->
  <main id="chatContainer" role="main" aria-label="Sohbet alanı">
    <div
      id="chat"
      class="chat-scroll flex flex-col space-y-4"
      aria-live="polite"
      aria-relevant="additions"
      role="log"
      tabindex="0"
    >
      <!-- No initial messages -->
    </div>

    <!-- Message input area -->
    <form
      id="chatForm"
      aria-label="Mesaj gönderme formu"
      autocomplete="off"
      novalidate
      class="relative flex items-center"
    >

      <textarea
        id="messageInput"
        rows="1"
        placeholder="cube'a sorun..."
        aria-label=""
        required
        spellcheck="false"
      ></textarea>
      <button
        id="sendBtn"
        type="submit"
        aria-label="Mesaj gönder"
        disabled
      >
        <i class="fas fa-paper-plane"></i>
      </button>
      <button
        id="stopBtn"
        type="button"
        aria-label="Mesaj yazmayı durdur"
      >
        <i class="fas fa-pause"></i>
      </button>
      <div id="typingSpinner" class="spinner" style="display:none;" aria-hidden="true"></div>
    </form>
  </main>


  <script>
    (() => {
      const menuButton = document.getElementById('menuButton');
      const menuOverlay = document.getElementById('menuOverlay');
      const closeBtn = menuOverlay.querySelector('button.closeBtn');
      const body = document.body;
      const chat = document.getElementById('chat');
      const chatForm = document.getElementById('chatForm');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const stopBtn = document.getElementById('stopBtn');
      const chatHistoryList = menuOverlay.querySelector('.chat-history-list');
      const newChatBtn = document.getElementById('newChatBtn');
      const typingSpinner = document.getElementById('typingSpinner');

      const profilePage = document.getElementById('profilePage');
      const settingsPage = document.getElementById('settingsPage');
      const modelsPage = document.getElementById('modelsPage');
      const openProfileBtn = document.getElementById('openProfileBtn');
      const openSettingsBtn = document.getElementById('openSettingsBtn');
      const openModelsBtn = document.getElementById('openModelsBtn');
      const openModelsBtnNavbar = document.getElementById('openModelsBtnNavbar');
      const profileCloseBtn = profilePage.querySelector('button.closePageBtn');
      const settingsCloseBtn = settingsPage.querySelector('button.closePageBtn');
      const modelsCloseBtn = modelsPage.querySelector('button.closePageBtn');
      const saveSettingsBtn = settingsPage.querySelector('button.saveSettingsBtn');
      const themeSelect = document.getElementById('themeSelect');
      const fontSizeSelect = document.getElementById('fontSizeSelect');
      const languageSelect = document.getElementById('languageSelect');
      const profileNameInput = document.getElementById('profileName');
      const profileEmailInput = document.getElementById('profileEmail');
      const selectedModelName = document.getElementById('selectedModelName');

      let editingMessageWrapper = null;
      let originalMessageText = '';
      let editTextarea = null;
      let editButtonsContainer = null;

      let currentSessionId = null;

      // Default model and API key
      let currentModel = localStorage.getItem('cube_ai_selected_model') || 'gpt-3.5-turbo';
      let currentApiKey = localStorage.getItem('cube_ai_openai_key') || '';
      selectedModelName.textContent = currentModel;

      // Update model buttons UI to reflect selected model
      function updateModelButtonsUI() {
        const buttons = document.querySelectorAll('.select-model-btn');
        buttons.forEach(btn => {
          if (btn.getAttribute('data-model') === currentModel) {
            btn.classList.add('model-selected');
            btn.textContent = 'Seçili';
            btn.disabled = true;
          } else {
            btn.classList.remove('model-selected');
            btn.textContent = 'Seç';
            btn.disabled = false;
          }
        });
      }
      updateModelButtonsUI();

      function toggleSendButton() {
        sendBtn.disabled = messageInput.value.trim().length === 0 || messageInput.disabled;
        if (!sendBtn.disabled) {
          sendBtn.style.backgroundColor = '#fff';
          sendBtn.style.color = '#000';
          sendBtn.style.cursor = 'pointer';
        } else {
          sendBtn.style.backgroundColor = '#bbb';
          sendBtn.style.color = '#666';
          sendBtn.style.cursor = 'not-allowed';
        }
      }
      messageInput.addEventListener('input', () => {
        toggleSendButton();
        autoResizeTextarea();
        messageInput.style.color = '#fff';
      });
      toggleSendButton();

      function autoResizeTextarea() {
        if (messageInput.value.trim() === '') {
          messageInput.style.height = '2.75rem';
        } else {
          messageInput.style.height = 'auto';
          messageInput.style.height = messageInput.scrollHeight + 'px';
        }
      }
      autoResizeTextarea();

      function openMenu() {
        menuOverlay.classList.add('open');
        menuOverlay.setAttribute('aria-hidden', 'false');
        menuButton.setAttribute('aria-expanded', 'true');
        body.classList.add('menu-open');
        const firstLink = menuOverlay.querySelector('nav a, nav button');
        if (firstLink) firstLink.focus();
      }

      function closeMenu() {
        menuOverlay.classList.remove('open');
        menuOverlay.setAttribute('aria-hidden', 'true');
        menuButton.setAttribute('aria-expanded', 'false');
        body.classList.remove('menu-open');
        menuButton.focus();
      }

      menuButton.addEventListener('click', () => {
        if (menuOverlay.classList.contains('open')) {
          closeMenu();
        } else {
          openMenu();
        }
      });

      closeBtn.addEventListener('click', () => {
        closeMenu();
      });

      menuOverlay.addEventListener('click', (e) => {
        if (e.target === menuOverlay) {
          closeMenu();
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (menuOverlay.classList.contains('open')) {
            e.preventDefault();
            closeMenu();
          }
          if (profilePage.classList.contains('open')) {
            e.preventDefault();
            closeProfilePage();
          }
          if (settingsPage.classList.contains('open')) {
            e.preventDefault();
            closeSettingsPage();
          }
          if (modelsPage.classList.contains('open')) {
            e.preventDefault();
            closeModelsPage();
          }
          if (editingMessageWrapper) {
            e.preventDefault();
            cancelEdit();
          }
        }
      });

      const STORAGE_KEY = 'cube_ai_chat_history';

      function cleanOldSessions(history) {
        const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
        const now = Date.now();
        return history.filter(session => (now - session.timestamp) <= SEVEN_DAYS_MS);
      }

      function loadChatHistory() {
        const historyJSON = localStorage.getItem(STORAGE_KEY);
        if (!historyJSON) return [];
        try {
          let history = JSON.parse(historyJSON);
          if (!Array.isArray(history)) return [];
          history = cleanOldSessions(history);
          saveChatHistory(history);
          return history;
        } catch {
          return [];
        }
      }

      function saveChatHistory(history) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
      }

      function formatDate(timestamp) {
        const d = new Date(timestamp);
        return d.toLocaleDateString('tr-TR', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
        });
      }

      function renderChatHistoryList(history) {
        chatHistoryList.innerHTML = '';
        if (history.length === 0) {
          const emptyMsg = document.createElement('p');
          emptyMsg.textContent = 'Sohbet geçmişi boş.';
          emptyMsg.className = 'text-gray-500 text-center select-none';
          chatHistoryList.appendChild(emptyMsg);
          return;
        }
        // Render newest first (history sorted descending by timestamp)
        const sortedHistory = [...history].sort((a, b) => b.timestamp - a.timestamp);
        sortedHistory.forEach((chatItem) => {
          const btn = document.createElement('button');
          btn.type = 'button';

          let firstMsg = 'Sohbet';
          if (chatItem.user.length > 0) {
            firstMsg = chatItem.user[0];
          } else if (chatItem.ai.length > 0) {
            firstMsg = chatItem.ai[0];
          }
          const displayText = firstMsg.length > 30 ? firstMsg.slice(0, 27) + '...' : firstMsg;

          btn.title = 'Sohbeti yükle: ' + displayText;

          const msgSpan = document.createElement('span');
          msgSpan.textContent = displayText;
          msgSpan.className = 'flex-1 truncate';

          const dateSpan = document.createElement('span');
          dateSpan.textContent = formatDate(chatItem.timestamp);
          dateSpan.className = 'date';

          btn.appendChild(msgSpan);
          btn.appendChild(dateSpan);

          btn.addEventListener('click', () => {
            loadChatIntoChatArea(chatItem);
            currentUserMessages = [...chatItem.user];
            currentAIMessages = [...chatItem.ai];
            currentSessionId = chatItem.id || null;
            closeMenu();
          });
          chatHistoryList.appendChild(btn);
        });
      }

      function loadChatIntoChatArea(chatItem) {
        chat.innerHTML = '';
        for (let i = 0; i < chatItem.user.length; i++) {
          const userMsgEl = createMessageElement(chatItem.user[i], true, true);
          chat.appendChild(userMsgEl);
          if (chatItem.ai[i]) {
            const aiMsgEl = createMessageElement(chatItem.ai[i], false, true);
            chat.appendChild(aiMsgEl);
          }
        }
        scrollChatToBottom();
        updateAllActionBarsState();
      }

      function extractCodeBlocks(text) {
        const codeBlockRegex = /```([\s\S]*?)```/g;
        let match;
        const parts = [];
        let lastIndex = 0;
        while ((match = codeBlockRegex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            parts.push({ type: 'text', content: text.slice(lastIndex, match.index) });
          }
          parts.push({ type: 'code', content: match[1].trim() });
          lastIndex = codeBlockRegex.lastIndex;
        }
        if (lastIndex < text.length) {
          parts.push({ type: 'text', content: text.slice(lastIndex) });
        }
        return parts;
      }

      function createMessageElement(message, isUser, instant = false) {
        const wrapper = document.createElement('div');
        wrapper.classList.add('message-wrapper');
        wrapper.classList.add(isUser ? 'user' : 'ai');

        const messageBubble = document.createElement('div');
        messageBubble.classList.add('message');
        messageBubble.classList.add(isUser ? 'user' : 'ai');
        messageBubble.setAttribute('role', 'article');
        messageBubble.setAttribute(
          'aria-label',
          isUser ? 'Kullanıcı mesajı' : 'Cube AI mesajı'
        );
        messageBubble.tabIndex = 0;

        if (isUser) {
          messageBubble.textContent = message;
          wrapper.appendChild(messageBubble);
          addActionBar(wrapper, messageBubble, isUser);
          return wrapper;
        } else {
          wrapper.appendChild(messageBubble);
          if (instant) {
            renderAIMessageContent(messageBubble, message);
            addActionBar(wrapper, messageBubble, isUser);
          } else {
            let index = 0;
            function typeLetter() {
              if (index < message.length) {
                messageBubble.textContent += message.charAt(index);
                index++;
                scrollChatToBottom();
                setTimeout(typeLetter, 30);
              }
            }
            typeLetter();
            addActionBar(wrapper, messageBubble, isUser);
          }
          return wrapper;
        }
      }

      function renderAIMessageContent(container, message) {
        container.innerHTML = '';
        const parts = extractCodeBlocks(message);
        parts.forEach(part => {
          if (part.type === 'text') {
            const p = document.createElement('p');
            p.textContent = part.content;
            p.style.margin = '0 0 0.5rem 0';
            container.appendChild(p);
          } else if (part.type === 'code') {
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            code.textContent = part.content;
            pre.appendChild(code);
            container.appendChild(pre);

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.type = 'button';
            copyBtn.textContent = 'Kopyala';
            copyBtn.setAttribute('aria-label', 'Kod bloğunu kopyala');
            copyBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              navigator.clipboard.writeText(part.content).then(() => {
                copyBtn.textContent = 'Kopyalandı!';
                setTimeout(() => {
                  copyBtn.textContent = 'Kopyala';
                }, 1500);
              }).catch(() => {
                copyBtn.textContent = 'Hata!';
                setTimeout(() => {
                  copyBtn.textContent = 'Kopyala';
                }, 1500);
              });
            });
            pre.appendChild(copyBtn);
          }
        });
      }

      function scrollChatToBottom() {
        chat.scrollTo({
          top: chat.scrollHeight,
          behavior: 'smooth',
        });
      }

      let currentUserMessages = [];
      let currentAIMessages = [];

      let isTyping = false;
      let typingTimeoutId = null;
      let typingIndex = 0;
      let currentAIMessage = '';
      let currentAIBubble = null;

      // Offline AI response simulation for offline mode
      function getOfflineResponse(prompt, lang) {
        const responses = {
          tr: "Üzgünüm, şu anda çevrimdışı modda çalışıyorum. Lütfen internet bağlantınızı kontrol edin.",
          en: "Sorry, I am currently running in offline mode. Please check your internet connection.",
          de: "Entschuldigung, ich arbeite derzeit im Offline-Modus. Bitte überprüfen Sie Ihre Internetverbindung.",
          fr: "Désolé, je fonctionne actuellement en mode hors ligne. Veuillez vérifier votre connexion Internet.",
          es: "Lo siento, actualmente estoy funcionando en modo sin conexión. Por favor, verifica tu conexión a internet.",
          zh: "抱歉，我目前处于离线模式。请检查您的网络连接。",
          ja: "申し訳ありませんが、現在オフラインモードで動作しています。インターネット接続を確認してください。",
          ru: "Извините, я сейчас работаю в автономном режиме. Пожалуйста, проверьте ваше интернет-соединение.",
          ar: "عذرًا، أنا أعمل حاليًا في وضع عدم الاتصال. يرجى التحقق من اتصال الإنترنت الخاص بك.",
          pt: "Desculpe, estou funcionando no modo offline no momento. Por favor, verifique sua conexão com a internet.",
          hi: "क्षमा करें, मैं वर्तमान में ऑफ़लाइन मोड में काम कर रहा हूँ। कृपया अपना इंटरनेट कनेक्शन जांचें।",
          it: "Spiacente, attualmente sto funzionando in modalità offline. Controlla la tua connessione internet.",
          ko: "죄송합니다. 현재 오프라인 모드로 작동 중입니다. 인터넷 연결을 확인하세요.",
          nl: "Sorry, ik werk momenteel offline. Controleer uw internetverbinding.",
          sv: "Tyvärr kör jag för närvarande i offline-läge. Kontrollera din internetanslutning.",
          pl: "Przepraszam, obecnie działam w trybie offline. Sprawdź swoje połączenie internetowe.",
          fi: "Valitettavasti toimin tällä hetkellä offline-tilassa. Tarkista internet-yhteytesi.",
          no: "Beklager, jeg kjører for øyeblikket i frakoblet modus. Vennligst sjekk internettforbindelsen din.",
          da: "Beklager, jeg kører i øjeblikket i offline-tilstand. Tjek din internetforbindelse.",
          cs: "Omlouvám se, momentálně pracuji v offline režimu. Zkontrolujte své internetové připojení.",
          el: "Συγγνώμη, αυτή τη στιγμή λειτουργώ σε λειτουργία εκτός σύνδεσης. Ελέγξτε τη σύνδεσή σας στο διαδίκτυο.",
          he: "מצטער, אני כרגע במצב לא מקוון. אנא בדוק את חיבור האינטרנט שלך.",
          th: "ขออภัย ฉันกำลังทำงานในโหมดออฟไลน์ กรุณาตรวจสอบการเชื่อมต่ออินเทอร์เน็ตของคุณ",
          vi: "Xin lỗi, tôi hiện đang hoạt động ở chế độ ngoại tuyến. Vui lòng kiểm tra kết nối internet của bạn.",
          id: "Maaf, saya sedang berjalan dalam mode offline. Silakan periksa koneksi internet Anda."
        };
        return responses[lang] || responses['en'];
      }

      // Fetch AI response based on selected model and API key
      async function fetchOpenAIResponse(prompt) {
        if (!currentApiKey) {
          const lang = languageSelect.value || 'en';
          return getOfflineResponse(prompt, lang);
        }

        if (currentModel === 'gemini-1.5' || currentModel === 'gemini-2.5') {
          const modelBtn = document.querySelector(`.select-model-btn[data-model="${currentModel}"]`);
          const apiKey = modelBtn ? modelBtn.getAttribute('data-api-key') : null;
          if (!apiKey) {
            const lang = languageSelect.value || 'en';
            return getOfflineResponse(prompt, lang);
          }

          const apiUrl = 'https://api.openai.com/v1/chat/completions';

          const requestBody = {
            model: currentModel,
            messages: [{ role: 'user', content: prompt }],
            max_tokens: 500,
            temperature: 0.7,
            n: 1,
            stop: null,
          };

          try {
            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${apiKey}`,
              },
              body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
              throw new Error(`API error: ${response.status}`);
            }

            const data = await response.json();
            if (data.choices && data.choices.length > 0) {
              return data.choices[0].message.content.trim();
            } else {
              return 'Üzgünüm, yanıt alınamadı.';
            }
          } catch (error) {
            const lang = languageSelect.value || 'en';
            return getOfflineResponse(prompt, lang);
          }
        } else {
          const apiUrl = 'https://api.openai.com/v1/chat/completions';

          const requestBody = {
            model: currentModel,
            messages: [{ role: 'user', content: prompt }],
            max_tokens: 500,
            temperature: 0.7,
            n: 1,
            stop: null,
          };

          try {
            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentApiKey}`,
              },
              body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
              throw new Error(`API error: ${response.status}`);
            }

            const data = await response.json();
            if (data.choices && data.choices.length > 0) {
              return data.choices[0].message.content.trim();
            } else {
              return 'Üzgünüm, yanıt alınamadı.';
            }
          } catch (error) {
            const lang = languageSelect.value || 'en';
            return getOfflineResponse(prompt, lang);
          }
        }
      }

      chatForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (isTyping) {
          pauseTyping();
          return;
        }
        const userMessageRaw = messageInput.value.trim();
        if (!userMessageRaw) return;

        let userMessage = userMessageRaw;
        if (sentiment) {
          const prediction = sentiment.predict(userMessageRaw);
          const score = prediction.score;
          let sentimentLabel = 'Nötr';
          if (score > 0.66) sentimentLabel = 'Olumlu';
          else if (score < 0.33) sentimentLabel = 'Olumsuz';

          userMessage = `[Duygu: ${sentimentLabel}] ${userMessageRaw}`;
        }

        const userMsgEl = createMessageElement(userMessage, true);
        chat.appendChild(userMsgEl);
        scrollChatToBottom();

        currentUserMessages.push(userMessage);

        messageInput.value = '';
        toggleSendButton();
        autoResizeTextarea();
        messageInput.style.height = '2.75rem';
        messageInput.style.color = '#fff';
        messageInput.focus();

        messageInput.disabled = true;
        sendBtn.disabled = true;

        typingSpinner.style.display = 'inline-block';
        sendBtn.style.display = 'none';
        stopBtn.style.display = 'none';

        // Disable all action bars while typing
        setAllActionBarsDisabled(true);

        setTimeout(async () => {
          typingSpinner.style.display = 'none';
          sendBtn.style.display = 'none';
          stopBtn.style.display = 'flex';

          const aiResponse = await fetchOpenAIResponse(userMessage);

          const aiMsgEl = createMessageElement('', false);
          chat.appendChild(aiMsgEl);
          scrollChatToBottom();

          isTyping = true;
          typingIndex = 0;
          currentAIMessage = aiResponse;
          currentAIBubble = aiMsgEl.querySelector('.message.ai');

          // Disable all action bars while typing
          setAllActionBarsDisabled(true);

          function typeLetter() {
            if (!isTyping) return;
            if (typingIndex < currentAIMessage.length) {
              currentAIBubble.textContent += currentAIMessage.charAt(typingIndex);
              typingIndex++;
              scrollChatToBottom();
              typingTimeoutId = setTimeout(typeLetter, 30);
            } else {
              finishTyping();
            }
          }
          typeLetter();
        }, 500);
      });

      function pauseTyping() {
        if (!isTyping) return;
        isTyping = false;
        if (typingTimeoutId) {
          clearTimeout(typingTimeoutId);
          typingTimeoutId = null;
        }
        stopBtn.style.display = 'none';
        sendBtn.style.display = 'flex';
        messageInput.disabled = false;
        toggleSendButton();
        messageInput.focus();

        // Enable all action bars when typing stopped
        setAllActionBarsDisabled(false);
      }

      function finishTyping() {
        isTyping = false;
        typingTimeoutId = null;
        renderAIMessageContent(currentAIBubble, currentAIMessage);
        currentAIBubble = null;
        typingIndex = 0;

        messageInput.disabled = false;
        toggleSendButton();
        messageInput.focus();

        stopBtn.style.display = 'none';
        sendBtn.style.display = 'flex';

        if (currentAIMessages.length < currentUserMessages.length) {
          currentAIMessages.push(currentAIMessage || '');
        }

        saveCurrentChatSession();
        renderChatHistoryList(loadChatHistory());

        // Enable all action bars when typing finished
        setAllActionBarsDisabled(false);
      }

      stopBtn.addEventListener('click', () => {
        pauseTyping();
      });

      newChatBtn.addEventListener('click', () => {
        if (isTyping) {
          pauseTyping();
        }
        currentUserMessages = [];
        currentAIMessages = [];
        chat.innerHTML = '';
        messageInput.value = '';
        toggleSendButton();
        autoResizeTextarea();
        messageInput.style.height = '2.75rem';
        messageInput.style.color = '#fff';
        messageInput.disabled = false;
        sendBtn.disabled = true;
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
        typingSpinner.style.display = 'none';
        closeMenu();
        messageInput.focus();
        currentSessionId = null;

        // Enable all action bars on new chat
        setAllActionBarsDisabled(false);
      });

      function saveCurrentChatSession() {
        if (currentUserMessages.length === 0) return;
        const history = loadChatHistory();

        if (currentSessionId) {
          const index = history.findIndex(session => session.id === currentSessionId);
          if (index !== -1) {
            history[index] = {
              id: currentSessionId,
              user: [...currentUserMessages],
              ai: [...currentAIMessages],
              timestamp: Date.now(),
            };
          } else {
            history.unshift({
              id: currentSessionId,
              user: [...currentUserMessages],
              ai: [...currentAIMessages],
              timestamp: Date.now(),
            });
          }
        } else {
          currentSessionId = 'session-' + Date.now() + '-' + Math.floor(Math.random() * 1000000);
          history.unshift({
            id: currentSessionId,
            user: [...currentUserMessages],
            ai: [...currentAIMessages],
            timestamp: Date.now(),
          });
        }

        if (history.length > 20) {
          history.sort((a, b) => b.timestamp - a.timestamp);
          history.length = 20;
        }

        saveChatHistory(history);
      }

      function openProfilePage() {
        closeMenu();
        closeSettingsPage();
        closeModelsPage();
        profilePage.classList.add('open');
        profilePage.setAttribute('aria-hidden', 'false');
        profilePage.focus();
      }
      function closeProfilePage() {
        profilePage.classList.remove('open');
        profilePage.setAttribute('aria-hidden', 'true');
        menuButton.focus();
      }
      function openSettingsPage() {
        closeMenu();
        closeProfilePage();
        closeModelsPage();
        settingsPage.classList.add('open');
        settingsPage.setAttribute('aria-hidden', 'false');
        settingsPage.focus();
      }
      function closeSettingsPage() {
        settingsPage.classList.remove('open');
        settingsPage.setAttribute('aria-hidden', 'true');
        menuButton.focus();
      }
      function openModelsPage() {
        closeMenu();
        closeProfilePage();
        closeSettingsPage();
        modelsPage.classList.add('open');
        modelsPage.setAttribute('aria-hidden', 'false');
        modelsPage.focus();
      }
      function closeModelsPage() {
        modelsPage.classList.remove('open');
        modelsPage.setAttribute('aria-hidden', 'true');
        menuButton.focus();
      }

      openProfileBtn.addEventListener('click', openProfilePage);
      profileCloseBtn.addEventListener('click', closeProfilePage);

      openSettingsBtn.addEventListener('click', openSettingsPage);
      settingsCloseBtn.addEventListener('click', closeSettingsPage);

      openModelsBtn.addEventListener('click', openModelsPage);
      openModelsBtnNavbar.addEventListener('click', openModelsPage);
      modelsCloseBtn.addEventListener('click', closeModelsPage);

      saveSettingsBtn.addEventListener('click', () => {
        const theme = themeSelect.value;
        const fontSize = fontSizeSelect.value;
        const language = languageSelect.value;

        localStorage.setItem('cube_ai_theme', theme);
        localStorage.setItem('cube_ai_fontSize', fontSize);
        localStorage.setItem('cube_ai_language', language);

        applySettings(theme, fontSize);
        alert('Ayarlar kaydedildi.');
      });

      // Model selection logic
      document.querySelectorAll('.select-model-btn').forEach(button => {
        button.addEventListener('click', () => {
          const model = button.getAttribute('data-model');
          const apiKey = button.getAttribute('data-api-key') || '';
          if (model) {
            currentModel = model;
            currentApiKey = apiKey;
            localStorage.setItem('cube_ai_selected_model', currentModel);
            localStorage.setItem('cube_ai_openai_key', currentApiKey);
            selectedModelName.textContent = currentModel;
            updateModelButtonsUI();
            alert(`Model "${currentModel}" seçildi.`);
          }
        });
      });

      function applySettings(theme, fontSize) {
        if (theme === 'light') {
          document.body.style.backgroundColor = '#f9fafb';
          document.body.style.color = '#111827';
          chat.style.backgroundColor = '#ffffff';
          messageInput.style.backgroundColor = '#f3f4f6';
          messageInput.style.color = '#111827';
          messageInput.style.borderColor = '#9ca3af';
          sendBtn.style.color = '#111827';
          sendBtn.style.backgroundColor = '#e5e7eb';
          stopBtn.style.color = '#111827';
          stopBtn.style.backgroundColor = '#e5e7eb';
          document.querySelectorAll('.message.user').forEach(el => {
            el.style.backgroundColor = '#e0e7ff';
            el.style.color = '#1e293b';
          });
          document.querySelectorAll('.message.ai').forEach(el => {
            el.style.backgroundColor = '#f3f4f6';
            el.style.color = '#374151';
          });
          document.querySelectorAll('.message.ai pre').forEach(pre => {
            pre.style.backgroundColor = '#d1d5db';
            pre.style.color = '#1f2937';
          });
          document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.style.backgroundColor = 'rgba(0,0,0,0.1)';
            btn.style.color = '#374151';
          });
        } else {
          document.body.style.backgroundColor = '#000';
          document.body.style.color = '#fff';
          chat.style.backgroundColor = '#000';
          messageInput.style.backgroundColor = '#111';
          messageInput.style.color = '#fff';
          messageInput.style.borderColor = '#555';
          sendBtn.style.color = '#000';
          sendBtn.style.backgroundColor = '#fff';
          stopBtn.style.color = '#000';
          stopBtn.style.backgroundColor = '#fff';
          document.querySelectorAll('.message.user').forEach(el => {
            el.style.backgroundColor = '#fff';
            el.style.color = '#000';
          });
          document.querySelectorAll('.message.ai').forEach(el => {
            el.style.backgroundColor = '#111';
            el.style.color = '#ccc';
          });
          document.querySelectorAll('.message.ai pre').forEach(pre => {
            pre.style.backgroundColor = '#222';
            pre.style.color = '#ccc';
          });
          document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.style.backgroundColor = 'rgba(255,255,255,0.2)';
            btn.style.color = '#ccc';
          });
        }

        if (fontSize === 'small') {
          chat.style.fontSize = '0.85rem';
          messageInput.style.fontSize = '0.85rem';
        } else if (fontSize === 'large') {
          chat.style.fontSize = '1.25rem';
          messageInput.style.fontSize = '1.25rem';
        } else {
          chat.style.fontSize = '1rem';
          messageInput.style.fontSize = '1rem';
        }
      }

      function loadProfile() {
        const name = localStorage.getItem('cube_ai_profile_name') || '';
        const email = localStorage.getItem('cube_ai_profile_email') || '';
        profileNameInput.value = name;
        profileEmailInput.value = email;
      }

      profileNameInput.addEventListener('blur', () => {
        localStorage.setItem('cube_ai_profile_name', profileNameInput.value.trim());
      });
      profileEmailInput.addEventListener('blur', () => {
        localStorage.setItem('cube_ai_profile_email', profileEmailInput.value.trim());
      });

      function loadLanguage() {
        const lang = localStorage.getItem('cube_ai_language') || 'tr';
        languageSelect.value = lang;
      }

      window.addEventListener('load', () => {
        renderChatHistoryList(loadChatHistory());
        loadProfile();
        loadLanguage();
        const savedTheme = localStorage.getItem('cube_ai_theme') || 'dark';
        const savedFontSize = localStorage.getItem('cube_ai_fontSize') || 'medium';
        themeSelect.value = savedTheme;
        fontSizeSelect.value = savedFontSize;
        applySettings(savedTheme, savedFontSize);
        setTimeout(() => {
          if (initialLoadingOverlay) {
            initialLoadingOverlay.style.opacity = '0';
            initialLoadingOverlay.style.pointerEvents = 'none';
            setTimeout(() => {
              initialLoadingOverlay.style.display = 'none';
            }, 500);
          }
        }, 800);
      });

      let sentiment;
      ml5.sentiment('movieReviews').then(model => {
        sentiment = model;
      });

      function addActionBar(wrapper, messageBubble, isUserMessage) {
        const actionBar = document.createElement('div');
        actionBar.className = 'action-bar';

        const copyBtn = document.createElement('button');
        copyBtn.type = 'button';
        copyBtn.title = 'Kopyala';
        copyBtn.setAttribute('aria-label', 'Mesajı kopyala');
        copyBtn.innerHTML = '<i class="fas fa-copy" aria-hidden="true"></i> Kopyala';
        copyBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isTyping) return; // Disable copy while typing
          navigator.clipboard.writeText(getMessageText(messageBubble)).then(() => {
            copyBtn.textContent = 'Kopyalandı!';
            setTimeout(() => {
              copyBtn.innerHTML = '<i class="fas fa-copy" aria-hidden="true"></i> Kopyala';
            }, 1500);
          }).catch(() => {
            copyBtn.textContent = 'Hata!';
            setTimeout(() => {
              copyBtn.innerHTML = '<i class="fas fa-copy" aria-hidden="true"></i> Kopyala';
            }, 1500);
          });
        });
        actionBar.appendChild(copyBtn);

        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.title = 'Düzenle';
        editBtn.setAttribute('aria-label', 'Mesajı düzenle');
        editBtn.innerHTML = '<i class="fas fa-edit" aria-hidden="true"></i> Düzenle';
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isTyping) return; // Disable edit while typing
          startEditMessage(wrapper, messageBubble, isUserMessage);
        });
        actionBar.appendChild(editBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.title = 'Sil';
        deleteBtn.setAttribute('aria-label', 'Mesajı sil');
        deleteBtn.innerHTML = '<i class="fas fa-trash" aria-hidden="true"></i> Sil';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isTyping) return; // Disable delete while typing
          if (confirm('Bu mesajı silmek istediğinize emin misiniz?')) {
            deleteMessage(wrapper, isUserMessage);
          }
        });
        actionBar.appendChild(deleteBtn);

        if (!isUserMessage) {
          const rewriteBtn = document.createElement('button');
          rewriteBtn.type = 'button';
          rewriteBtn.title = 'Yeniden Yazdır';
          rewriteBtn.setAttribute('aria-label', 'Mesajı yeniden yazdır');
          rewriteBtn.innerHTML = '<i class="fas fa-redo" aria-hidden="true"></i> Yeniden Yaz';
          rewriteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isTyping) return; // Disable rewrite while typing
            rewriteAIMessage(getMessageText(messageBubble));
          });
          actionBar.appendChild(rewriteBtn);
        }

        wrapper.appendChild(actionBar);

        // Set initial disabled state based on isTyping
        if (isTyping) {
          actionBar.classList.add('disabled');
        } else {
          actionBar.classList.remove('disabled');
        }
      }

      function setAllActionBarsDisabled(disabled) {
        const actionBars = chat.querySelectorAll('.action-bar');
        actionBars.forEach(bar => {
          if (disabled) {
            bar.classList.add('disabled');
          } else {
            bar.classList.remove('disabled');
          }
        });
      }

      function updateAllActionBarsState() {
        if (isTyping) {
          setAllActionBarsDisabled(true);
        } else {
          setAllActionBarsDisabled(false);
        }
      }

      function getMessageText(messageBubble) {
        if (messageBubble.classList.contains('ai')) {
          let text = '';
          messageBubble.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
              text += node.textContent;
            } else if (node.nodeName === 'P') {
              text += node.textContent + '\n';
            } else if (node.nodeName === 'PRE') {
              text += '```' + node.textContent + '```\n';
            }
          });
          return text.trim();
        } else {
          return messageBubble.textContent.trim();
        }
      }

      function startEditMessage(wrapper, messageBubble, isUserMessage) {
        if (editingMessageWrapper) {
          cancelEdit();
        }
        editingMessageWrapper = wrapper;
        originalMessageText = getMessageText(messageBubble);

        const actionBar = wrapper.querySelector('.action-bar');
        if (actionBar) actionBar.style.display = 'none';

        messageBubble.innerHTML = '';

        editTextarea = document.createElement('textarea');
        editTextarea.className = 'edit-textarea';
        editTextarea.value = originalMessageText;
        editTextarea.setAttribute('aria-label', 'Mesaj düzenleme alanı');
        messageBubble.appendChild(editTextarea);

        editButtonsContainer = document.createElement('div');
        editButtonsContainer.className = 'edit-buttons';

        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.textContent = 'Kaydet';
        saveBtn.addEventListener('click', () => {
          saveEdit(wrapper, messageBubble, isUserMessage);
        });
        editButtonsContainer.appendChild(saveBtn);

        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.textContent = 'İptal';
        cancelBtn.className = 'cancel-btn';
        cancelBtn.addEventListener('click', () => {
          cancelEdit();
        });
        editButtonsContainer.appendChild(cancelBtn);

        messageBubble.appendChild(editButtonsContainer);

        editTextarea.focus();
        editTextarea.select();
      }

      function saveEdit(wrapper, messageBubble, isUserMessage) {
        if (!editingMessageWrapper || !editTextarea) return;
        const newText = editTextarea.value.trim();
        if (newText === '') {
          alert('Mesaj boş olamaz.');
          editTextarea.focus();
          return;
        }

        if (isUserMessage) {
          messageBubble.textContent = newText;
          updateMessageInSession(wrapper, newText, true);
        } else {
          renderAIMessageContent(messageBubble, newText);
          updateMessageInSession(wrapper, newText, false);
        }

        const actionBar = wrapper.querySelector('.action-bar');
        if (actionBar) actionBar.style.display = 'flex';

        editingMessageWrapper = null;
        editTextarea = null;
        editButtonsContainer = null;

        saveCurrentChatSession();
        renderChatHistoryList(loadChatHistory());
      }

      function cancelEdit() {
        if (!editingMessageWrapper) return;

        const messageBubble = editingMessageWrapper.querySelector('.message');
        if (messageBubble) {
          if (messageBubble.classList.contains('user')) {
            messageBubble.textContent = originalMessageText;
          } else {
            renderAIMessageContent(messageBubble, originalMessageText);
          }
        }

        const actionBar = editingMessageWrapper.querySelector('.action-bar');
        if (actionBar) actionBar.style.display = 'flex';

        editingMessageWrapper = null;
        editTextarea = null;
        editButtonsContainer = null;
      }

      function updateMessageInSession(wrapper, newText, isUserMessage) {
        const messages = Array.from(chat.querySelectorAll('.message-wrapper'));
        const index = messages.indexOf(wrapper);
        if (index === -1) return;

        if (isUserMessage) {
          let userMsgIndex = -1;
          let count = -1;
          for (let i = 0; i < messages.length; i++) {
            if (messages[i].classList.contains('user')) {
              count++;
              if (i === index) {
                userMsgIndex = count;
                break;
              }
            }
          }
          if (userMsgIndex !== -1 && userMsgIndex < currentUserMessages.length) {
            currentUserMessages[userMsgIndex] = newText;
          }
        } else {
          let aiMsgIndex = -1;
          let count = -1;
          for (let i = 0; i < messages.length; i++) {
            if (messages[i].classList.contains('ai')) {
              count++;
              if (i === index) {
                aiMsgIndex = count;
                break;
              }
            }
          }
          if (aiMsgIndex !== -1 && aiMsgIndex < currentAIMessages.length) {
            currentAIMessages[aiMsgIndex] = newText;
          }
        }
      }

      function deleteMessage(wrapper, isUserMessage) {
        const messages = Array.from(chat.querySelectorAll('.message-wrapper'));
        const index = messages.indexOf(wrapper);
        if (index === -1) return;

        if (isUserMessage) {
          const aiIndex = index + 1;
          if (aiIndex < messages.length && messages[aiIndex].classList.contains('ai')) {
            chat.removeChild(messages[aiIndex]);
            let aiMsgIndex = -1;
            let count = -1;
            for (let i = 0; i < messages.length; i++) {
              if (messages[i].classList.contains('ai')) {
                count++;
                if (i === aiIndex) {
                  aiMsgIndex = count;
                  break;
                }
              }
            }
            if (aiMsgIndex !== -1 && aiMsgIndex < currentAIMessages.length) {
              currentAIMessages.splice(aiMsgIndex, 1);
            }
          }
          chat.removeChild(wrapper);
          let userMsgIndex = -1;
          count = -1;
          for (let i = 0; i < messages.length; i++) {
            if (messages[i].classList.contains('user')) {
              count++;
              if (i === index) {
                userMsgIndex = count;
                break;
              }
            }
          }
          if (userMsgIndex !== -1 && userMsgIndex < currentUserMessages.length) {
            currentUserMessages.splice(userMsgIndex, 1);
          }
        } else {
          const userIndex = index - 1;
          if (userIndex >= 0 && messages[userIndex].classList.contains('user')) {
            chat.removeChild(wrapper);
            let aiMsgIndex = -1;
            let count = -1;
            for (let i = 0; i < messages.length; i++) {
              if (messages[i].classList.contains('ai')) {
                count++;
                if (i === index) {
                  aiMsgIndex = count;
                  break;
                }
              }
            }
            if (aiMsgIndex !== -1 && aiMsgIndex < currentAIMessages.length) {
              currentAIMessages.splice(aiMsgIndex, 1);
            }
          } else {
            chat.removeChild(wrapper);
            let aiMsgIndex = -1;
            let count = -1;
            for (let i = 0; i < messages.length; i++) {
              if (messages[i].classList.contains('ai')) {
                count++;
                if (i === index) {
                  aiMsgIndex = count;
                  break;
                }
              }
            }
            if (aiMsgIndex !== -1 && aiMsgIndex < currentAIMessages.length) {
              currentAIMessages.splice(aiMsgIndex, 1);
            }
          }
        }

        saveCurrentChatSession();
        renderChatHistoryList(loadChatHistory());
      }

      async function rewriteAIMessage(originalText) {
        if (isTyping) {
          pauseTyping();
        }
        messageInput.disabled = true;
        sendBtn.disabled = true;

        typingSpinner.style.display = 'inline-block';
        sendBtn.style.display = 'none';
        stopBtn.style.display = 'none';

        // Disable all action bars while typing
        setAllActionBarsDisabled(true);

        setTimeout(async () => {
          typingSpinner.style.display = 'none';
          sendBtn.style.display = 'none';
          stopBtn.style.display = 'flex';

          const aiResponse = await fetchOpenAIResponse(originalText);

          const wrappers = Array.from(chat.querySelectorAll('.message-wrapper.ai'));
          let targetWrapper = null;
          for (const w of wrappers) {
            const msg = w.querySelector('.message.ai');
            if (msg && getMessageText(msg) === originalText) {
              targetWrapper = w;
              break;
            }
          }
          if (!targetWrapper) {
            const aiMsgEl = createMessageElement('', false);
            chat.appendChild(aiMsgEl);
            targetWrapper = aiMsgEl;
          }

          const messageBubble = targetWrapper.querySelector('.message.ai');
          messageBubble.textContent = '';

          isTyping = true;
          typingIndex = 0;
          currentAIMessage = aiResponse;
          currentAIBubble = messageBubble;

          // Disable all action bars while typing
          setAllActionBarsDisabled(true);

          function typeLetter() {
            if (!isTyping) return;
            if (typingIndex < currentAIMessage.length) {
              currentAIBubble.textContent += currentAIMessage.charAt(typingIndex);
              typingIndex++;
              scrollChatToBottom();
              typingTimeoutId = setTimeout(typeLetter, 30);
            } else {
              finishTyping();
            }
          }
          typeLetter();
        }, 500);
      }

      chat.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;

        const action = btn.textContent.trim();
        const wrapper = btn.closest('.message-wrapper');
        if (!wrapper) return;
        const messageBubble = wrapper.querySelector('.message');
        if (!messageBubble) return;
        const isUserMessage = wrapper.classList.contains('user');

        if (action.includes('Kopyala')) {
          if (isTyping) return; // Disable copy while typing
          navigator.clipboard.writeText(getMessageText(messageBubble)).then(() => {
            btn.textContent = 'Kopyalandı!';
            setTimeout(() => {
              btn.innerHTML = '<i class="fas fa-copy" aria-hidden="true"></i> Kopyala';
            }, 1500);
          }).catch(() => {
            btn.textContent = 'Hata!';
            setTimeout(() => {
              btn.innerHTML = '<i class="fas fa-copy" aria-hidden="true"></i> Kopyala';
            }, 1500);
          });
        } else if (action.includes('Düzenle')) {
          if (isTyping) return; // Disable edit while typing
          startEditMessage(wrapper, messageBubble, isUserMessage);
        } else if (action.includes('Sil')) {
          if (isTyping) return; // Disable delete while typing
          if (confirm('Bu mesajı silmek istediğinize emin misiniz?')) {
            deleteMessage(wrapper, isUserMessage);
          }
        } else if (action.includes('Yeniden Yaz')) {
          if (isTyping) return; // Disable rewrite while typing
          rewriteAIMessage(getMessageText(messageBubble));
        }
      });

    })();
  </script>
</body>
</html>